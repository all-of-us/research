/*
 * Leonardo
 * Workbench notebooks service. 
 *
 * OpenAPI spec version: 0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package org.pmiops.workbench.notebooks.api;

import org.pmiops.workbench.notebooks.ApiCallback;
import org.pmiops.workbench.notebooks.ApiClient;
import org.pmiops.workbench.notebooks.ApiException;
import org.pmiops.workbench.notebooks.ApiResponse;
import org.pmiops.workbench.notebooks.Configuration;
import org.pmiops.workbench.notebooks.Pair;
import org.pmiops.workbench.notebooks.ProgressRequestBody;
import org.pmiops.workbench.notebooks.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.pmiops.workbench.notebooks.model.ErrorReport;
import org.pmiops.workbench.notebooks.model.Localize;
import org.pmiops.workbench.notebooks.model.StorageLink;
import org.pmiops.workbench.notebooks.model.WelderErrorReport;

import io.opencensus.common.Scope;
import io.opencensus.trace.AttributeValue;
import io.opencensus.trace.Span;
import io.opencensus.trace.Status;
import io.opencensus.trace.Tracer;
import io.opencensus.trace.Tracing;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class NotebooksApi {
    private static final Tracer tracer = Tracing.getTracer();
    private ApiClient apiClient;

    public NotebooksApi() {
        this(Configuration.getDefaultApiClient());
    }

    public NotebooksApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for invalidateToken
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call invalidateTokenCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/notebooks/invalidateToken";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "googleoauth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call invalidateTokenValidateBeforeCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        

        com.squareup.okhttp.Call call = invalidateTokenCall(progressListener, progressRequestListener);
        return call;





    }

    /**
     * (Deprecated) Invalidates a token
     * If using Google token-based auth, call this endpoint when a user&#39;s Google token is invalidated (e.g. when logging out of the application). This ensures that the token is also invalidated in Leo and that the user&#39;s proxied notebook connections stop working. 
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public void invalidateToken() throws ApiException {
                // Generate an OpenCensus tracing span for this API method call.
        Scope scope = tracer.spanBuilderWithExplicitParent("NotebooksApi.invalidateToken", tracer.getCurrentSpan())
            .setSpanKind(Span.Kind.CLIENT).startScopedSpan();
        Span span = tracer.getCurrentSpan();
        // Some of these attribute keys use naming from the OpenCensus standard. See
        // https://github.com/census-instrumentation/opencensus-specs/blob/master/trace/HTTP.md
        span.putAttribute("package", AttributeValue.stringAttributeValue("org.pmiops.workbench.notebooks.api"));
        span.putAttribute("http.host", AttributeValue.stringAttributeValue(apiClient.getBasePath()));
        span.putAttribute("http.path", AttributeValue.stringAttributeValue("/notebooks/invalidateToken"));
        span.putAttribute("http.method", AttributeValue.stringAttributeValue("GET"));
        span.putAttribute("description", AttributeValue.stringAttributeValue("(Deprecated) Invalidates a token"));
        span.putAttribute("connectionTimeout", AttributeValue.longAttributeValue(apiClient.getConnectTimeout()));

        try {
            // Create and execute the API request.
            invalidateTokenWithHttpInfo();
        } catch (ApiException e) {
            // We could be more intelligent about aligning HTTP error codes with OpenCensus canonical
            // status codes... but this is for tracing purposes, not logging / deeper debugging, so we'll
            // be lazy and use UNKNOWN, including the actual code as an attribute.
            span.setStatus(Status.UNKNOWN.withDescription(e.getMessage()));
            span.putAttribute("http.status_code", AttributeValue.longAttributeValue(e.getCode()));
            span.putAttribute("errorMessage", AttributeValue.stringAttributeValue(e.getMessage()));
            throw e;
        } finally {
            scope.close();
        }

    }

    /**
     * (Deprecated) Invalidates a token
     * If using Google token-based auth, call this endpoint when a user&#39;s Google token is invalidated (e.g. when logging out of the application). This ensures that the token is also invalidated in Leo and that the user&#39;s proxied notebook connections stop working. 
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> invalidateTokenWithHttpInfo() throws ApiException {
        com.squareup.okhttp.Call call = invalidateTokenValidateBeforeCall(null, null);
        return apiClient.execute(call);
    }

    /**
     * (Deprecated) Invalidates a token (asynchronously)
     * If using Google token-based auth, call this endpoint when a user&#39;s Google token is invalidated (e.g. when logging out of the application). This ensures that the token is also invalidated in Leo and that the user&#39;s proxied notebook connections stop working. 
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call invalidateTokenAsync(final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = invalidateTokenValidateBeforeCall(progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /**
     * Build call for proxyCluster
     * @param googleProject googleProject (required)
     * @param clusterName clusterName (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call proxyClusterCall(String googleProject, String clusterName, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/notebooks/{googleProject}/{clusterName}"
            .replaceAll("\\{" + "googleProject" + "\\}", apiClient.escapeString(googleProject.toString()))
            .replaceAll("\\{" + "clusterName" + "\\}", apiClient.escapeString(clusterName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "googleoauth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call proxyClusterValidateBeforeCall(String googleProject, String clusterName, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'googleProject' is set
        if (googleProject == null) {
            throw new ApiException("Missing the required parameter 'googleProject' when calling proxyCluster(Async)");
        }
        
        // verify the required parameter 'clusterName' is set
        if (clusterName == null) {
            throw new ApiException("Missing the required parameter 'clusterName' when calling proxyCluster(Async)");
        }
        

        com.squareup.okhttp.Call call = proxyClusterCall(googleProject, clusterName, progressListener, progressRequestListener);
        return call;





    }

    /**
     * (Deprecated) Access Jupyter notebooks on a Dataproc cluster
     * This URI supports all HTTP methods, not just GET as implied by this Swagger. Proxies all requests through to the Jupyter notebook server running on the given cluster. 
     * @param googleProject googleProject (required)
     * @param clusterName clusterName (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public void proxyCluster(String googleProject, String clusterName) throws ApiException {
                // Generate an OpenCensus tracing span for this API method call.
        Scope scope = tracer.spanBuilderWithExplicitParent("NotebooksApi.proxyCluster", tracer.getCurrentSpan())
            .setSpanKind(Span.Kind.CLIENT).startScopedSpan();
        Span span = tracer.getCurrentSpan();
        // Some of these attribute keys use naming from the OpenCensus standard. See
        // https://github.com/census-instrumentation/opencensus-specs/blob/master/trace/HTTP.md
        span.putAttribute("package", AttributeValue.stringAttributeValue("org.pmiops.workbench.notebooks.api"));
        span.putAttribute("http.host", AttributeValue.stringAttributeValue(apiClient.getBasePath()));
        span.putAttribute("http.path", AttributeValue.stringAttributeValue("/notebooks/{googleProject}/{clusterName}"));
        span.putAttribute("http.method", AttributeValue.stringAttributeValue("GET"));
        span.putAttribute("description", AttributeValue.stringAttributeValue("(Deprecated) Access Jupyter notebooks on a Dataproc cluster"));
        span.putAttribute("connectionTimeout", AttributeValue.longAttributeValue(apiClient.getConnectTimeout()));

        try {
            // Create and execute the API request.
            proxyClusterWithHttpInfo(googleProject, clusterName);
        } catch (ApiException e) {
            // We could be more intelligent about aligning HTTP error codes with OpenCensus canonical
            // status codes... but this is for tracing purposes, not logging / deeper debugging, so we'll
            // be lazy and use UNKNOWN, including the actual code as an attribute.
            span.setStatus(Status.UNKNOWN.withDescription(e.getMessage()));
            span.putAttribute("http.status_code", AttributeValue.longAttributeValue(e.getCode()));
            span.putAttribute("errorMessage", AttributeValue.stringAttributeValue(e.getMessage()));
            throw e;
        } finally {
            scope.close();
        }

    }

    /**
     * (Deprecated) Access Jupyter notebooks on a Dataproc cluster
     * This URI supports all HTTP methods, not just GET as implied by this Swagger. Proxies all requests through to the Jupyter notebook server running on the given cluster. 
     * @param googleProject googleProject (required)
     * @param clusterName clusterName (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> proxyClusterWithHttpInfo(String googleProject, String clusterName) throws ApiException {
        com.squareup.okhttp.Call call = proxyClusterValidateBeforeCall(googleProject, clusterName, null, null);
        return apiClient.execute(call);
    }

    /**
     * (Deprecated) Access Jupyter notebooks on a Dataproc cluster (asynchronously)
     * This URI supports all HTTP methods, not just GET as implied by this Swagger. Proxies all requests through to the Jupyter notebook server running on the given cluster. 
     * @param googleProject googleProject (required)
     * @param clusterName clusterName (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call proxyClusterAsync(String googleProject, String clusterName, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = proxyClusterValidateBeforeCall(googleProject, clusterName, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /**
     * Build call for proxyLocalize
     * @param googleProject googleProject (required)
     * @param clusterName clusterName (required)
     * @param filesToLocalize JSON object. Keys represent destinations, values represent sources. The following rules apply: * If either the source or destination is a GCS path, it will be sent to [gsutil cp](https://cloud.google.com/storage/docs/gsutil/commands/cp). Therefore   this can be used to localize a file _from_ a bucket _to_ the notebook server; or delocalize a file _from_ the notebook server _to_ a bucket. * If the source is a Data URI, then the destination file will be created with the decoded data URI contents. This mode can only be used to localize   files to the notebook server. In both cases all paths will be quoted &amp; sanitized, and intermediate local directories will be made. Note that duplicate keys will lead to unexpected behaviour, so specify the destination filename explicitly if you want to localize multiple files to the same directory.  (required)
     * @param async If true, the copy will happen asynchronously to the request and the API will always return 200. If false (the default), the copy will happen synchronously and the response will reflect any errors encountered during the copy.  (optional, default to false)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call proxyLocalizeCall(String googleProject, String clusterName, Object filesToLocalize, Boolean async, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = filesToLocalize;

        // create path and map variables
        String localVarPath = "/notebooks/{googleProject}/{clusterName}/api/localize"
            .replaceAll("\\{" + "googleProject" + "\\}", apiClient.escapeString(googleProject.toString()))
            .replaceAll("\\{" + "clusterName" + "\\}", apiClient.escapeString(clusterName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (async != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "async", async));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "googleoauth" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call proxyLocalizeValidateBeforeCall(String googleProject, String clusterName, Object filesToLocalize, Boolean async, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'googleProject' is set
        if (googleProject == null) {
            throw new ApiException("Missing the required parameter 'googleProject' when calling proxyLocalize(Async)");
        }
        
        // verify the required parameter 'clusterName' is set
        if (clusterName == null) {
            throw new ApiException("Missing the required parameter 'clusterName' when calling proxyLocalize(Async)");
        }
        
        // verify the required parameter 'filesToLocalize' is set
        if (filesToLocalize == null) {
            throw new ApiException("Missing the required parameter 'filesToLocalize' when calling proxyLocalize(Async)");
        }
        

        com.squareup.okhttp.Call call = proxyLocalizeCall(googleProject, clusterName, filesToLocalize, async, progressListener, progressRequestListener);
        return call;





    }

    /**
     * Localize files to/from a Jupyter notebook server
     * Sends a command to a Jupyter notebook server to localize files to/from the server. Supports GCS paths and [Data URIs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs). Output, including any errors, will appear in &#x60;localization.log&#x60; in the working directory of the Jupyter notebook server. By default this operation will happen synchronously and the response status will reflect any errors encountered in the copy. However, if the &#x60;async&#x60; parameter is specfied then the localization will happen asynchronously to the request, and the API will always return 200. 
     * @param googleProject googleProject (required)
     * @param clusterName clusterName (required)
     * @param filesToLocalize JSON object. Keys represent destinations, values represent sources. The following rules apply: * If either the source or destination is a GCS path, it will be sent to [gsutil cp](https://cloud.google.com/storage/docs/gsutil/commands/cp). Therefore   this can be used to localize a file _from_ a bucket _to_ the notebook server; or delocalize a file _from_ the notebook server _to_ a bucket. * If the source is a Data URI, then the destination file will be created with the decoded data URI contents. This mode can only be used to localize   files to the notebook server. In both cases all paths will be quoted &amp; sanitized, and intermediate local directories will be made. Note that duplicate keys will lead to unexpected behaviour, so specify the destination filename explicitly if you want to localize multiple files to the same directory.  (required)
     * @param async If true, the copy will happen asynchronously to the request and the API will always return 200. If false (the default), the copy will happen synchronously and the response will reflect any errors encountered during the copy.  (optional, default to false)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public void proxyLocalize(String googleProject, String clusterName, Object filesToLocalize, Boolean async) throws ApiException {
                // Generate an OpenCensus tracing span for this API method call.
        Scope scope = tracer.spanBuilderWithExplicitParent("NotebooksApi.proxyLocalize", tracer.getCurrentSpan())
            .setSpanKind(Span.Kind.CLIENT).startScopedSpan();
        Span span = tracer.getCurrentSpan();
        // Some of these attribute keys use naming from the OpenCensus standard. See
        // https://github.com/census-instrumentation/opencensus-specs/blob/master/trace/HTTP.md
        span.putAttribute("package", AttributeValue.stringAttributeValue("org.pmiops.workbench.notebooks.api"));
        span.putAttribute("http.host", AttributeValue.stringAttributeValue(apiClient.getBasePath()));
        span.putAttribute("http.path", AttributeValue.stringAttributeValue("/notebooks/{googleProject}/{clusterName}/api/localize"));
        span.putAttribute("http.method", AttributeValue.stringAttributeValue("POST"));
        span.putAttribute("description", AttributeValue.stringAttributeValue("Localize files to/from a Jupyter notebook server"));
        span.putAttribute("connectionTimeout", AttributeValue.longAttributeValue(apiClient.getConnectTimeout()));

        try {
            // Create and execute the API request.
            proxyLocalizeWithHttpInfo(googleProject, clusterName, filesToLocalize, async);
        } catch (ApiException e) {
            // We could be more intelligent about aligning HTTP error codes with OpenCensus canonical
            // status codes... but this is for tracing purposes, not logging / deeper debugging, so we'll
            // be lazy and use UNKNOWN, including the actual code as an attribute.
            span.setStatus(Status.UNKNOWN.withDescription(e.getMessage()));
            span.putAttribute("http.status_code", AttributeValue.longAttributeValue(e.getCode()));
            span.putAttribute("errorMessage", AttributeValue.stringAttributeValue(e.getMessage()));
            throw e;
        } finally {
            scope.close();
        }

    }

    /**
     * Localize files to/from a Jupyter notebook server
     * Sends a command to a Jupyter notebook server to localize files to/from the server. Supports GCS paths and [Data URIs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs). Output, including any errors, will appear in &#x60;localization.log&#x60; in the working directory of the Jupyter notebook server. By default this operation will happen synchronously and the response status will reflect any errors encountered in the copy. However, if the &#x60;async&#x60; parameter is specfied then the localization will happen asynchronously to the request, and the API will always return 200. 
     * @param googleProject googleProject (required)
     * @param clusterName clusterName (required)
     * @param filesToLocalize JSON object. Keys represent destinations, values represent sources. The following rules apply: * If either the source or destination is a GCS path, it will be sent to [gsutil cp](https://cloud.google.com/storage/docs/gsutil/commands/cp). Therefore   this can be used to localize a file _from_ a bucket _to_ the notebook server; or delocalize a file _from_ the notebook server _to_ a bucket. * If the source is a Data URI, then the destination file will be created with the decoded data URI contents. This mode can only be used to localize   files to the notebook server. In both cases all paths will be quoted &amp; sanitized, and intermediate local directories will be made. Note that duplicate keys will lead to unexpected behaviour, so specify the destination filename explicitly if you want to localize multiple files to the same directory.  (required)
     * @param async If true, the copy will happen asynchronously to the request and the API will always return 200. If false (the default), the copy will happen synchronously and the response will reflect any errors encountered during the copy.  (optional, default to false)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> proxyLocalizeWithHttpInfo(String googleProject, String clusterName, Object filesToLocalize, Boolean async) throws ApiException {
        com.squareup.okhttp.Call call = proxyLocalizeValidateBeforeCall(googleProject, clusterName, filesToLocalize, async, null, null);
        return apiClient.execute(call);
    }

    /**
     * Localize files to/from a Jupyter notebook server (asynchronously)
     * Sends a command to a Jupyter notebook server to localize files to/from the server. Supports GCS paths and [Data URIs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs). Output, including any errors, will appear in &#x60;localization.log&#x60; in the working directory of the Jupyter notebook server. By default this operation will happen synchronously and the response status will reflect any errors encountered in the copy. However, if the &#x60;async&#x60; parameter is specfied then the localization will happen asynchronously to the request, and the API will always return 200. 
     * @param googleProject googleProject (required)
     * @param clusterName clusterName (required)
     * @param filesToLocalize JSON object. Keys represent destinations, values represent sources. The following rules apply: * If either the source or destination is a GCS path, it will be sent to [gsutil cp](https://cloud.google.com/storage/docs/gsutil/commands/cp). Therefore   this can be used to localize a file _from_ a bucket _to_ the notebook server; or delocalize a file _from_ the notebook server _to_ a bucket. * If the source is a Data URI, then the destination file will be created with the decoded data URI contents. This mode can only be used to localize   files to the notebook server. In both cases all paths will be quoted &amp; sanitized, and intermediate local directories will be made. Note that duplicate keys will lead to unexpected behaviour, so specify the destination filename explicitly if you want to localize multiple files to the same directory.  (required)
     * @param async If true, the copy will happen asynchronously to the request and the API will always return 200. If false (the default), the copy will happen synchronously and the response will reflect any errors encountered during the copy.  (optional, default to false)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call proxyLocalizeAsync(String googleProject, String clusterName, Object filesToLocalize, Boolean async, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = proxyLocalizeValidateBeforeCall(googleProject, clusterName, filesToLocalize, async, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /**
     * Build call for setCookie
     * @param googleProject  (required)
     * @param clusterName clusterName (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call setCookieCall(String googleProject, String clusterName, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/notebooks/{googleProject}/{clusterName}/setCookie"
            .replaceAll("\\{" + "googleProject" + "\\}", apiClient.escapeString(googleProject.toString()))
            .replaceAll("\\{" + "clusterName" + "\\}", apiClient.escapeString(clusterName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "googleoauth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call setCookieValidateBeforeCall(String googleProject, String clusterName, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'googleProject' is set
        if (googleProject == null) {
            throw new ApiException("Missing the required parameter 'googleProject' when calling setCookie(Async)");
        }
        
        // verify the required parameter 'clusterName' is set
        if (clusterName == null) {
            throw new ApiException("Missing the required parameter 'clusterName' when calling setCookie(Async)");
        }
        

        com.squareup.okhttp.Call call = setCookieCall(googleProject, clusterName, progressListener, progressRequestListener);
        return call;





    }

    /**
     * (Deprecated) Sets a browser cookie needed to authorize connections to a Jupyter notebook
     * If using Google token-based authorization to a Jupyter notebook, the Leo proxy accepts a Google token passed as a cookie value. This endpoint facilitates setting that cookie. It accepts a bearer token in an Authorization header and responds with a Set-Cookie header. 
     * @param googleProject  (required)
     * @param clusterName clusterName (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public void setCookie(String googleProject, String clusterName) throws ApiException {
                // Generate an OpenCensus tracing span for this API method call.
        Scope scope = tracer.spanBuilderWithExplicitParent("NotebooksApi.setCookie", tracer.getCurrentSpan())
            .setSpanKind(Span.Kind.CLIENT).startScopedSpan();
        Span span = tracer.getCurrentSpan();
        // Some of these attribute keys use naming from the OpenCensus standard. See
        // https://github.com/census-instrumentation/opencensus-specs/blob/master/trace/HTTP.md
        span.putAttribute("package", AttributeValue.stringAttributeValue("org.pmiops.workbench.notebooks.api"));
        span.putAttribute("http.host", AttributeValue.stringAttributeValue(apiClient.getBasePath()));
        span.putAttribute("http.path", AttributeValue.stringAttributeValue("/notebooks/{googleProject}/{clusterName}/setCookie"));
        span.putAttribute("http.method", AttributeValue.stringAttributeValue("GET"));
        span.putAttribute("description", AttributeValue.stringAttributeValue("(Deprecated) Sets a browser cookie needed to authorize connections to a Jupyter notebook"));
        span.putAttribute("connectionTimeout", AttributeValue.longAttributeValue(apiClient.getConnectTimeout()));

        try {
            // Create and execute the API request.
            setCookieWithHttpInfo(googleProject, clusterName);
        } catch (ApiException e) {
            // We could be more intelligent about aligning HTTP error codes with OpenCensus canonical
            // status codes... but this is for tracing purposes, not logging / deeper debugging, so we'll
            // be lazy and use UNKNOWN, including the actual code as an attribute.
            span.setStatus(Status.UNKNOWN.withDescription(e.getMessage()));
            span.putAttribute("http.status_code", AttributeValue.longAttributeValue(e.getCode()));
            span.putAttribute("errorMessage", AttributeValue.stringAttributeValue(e.getMessage()));
            throw e;
        } finally {
            scope.close();
        }

    }

    /**
     * (Deprecated) Sets a browser cookie needed to authorize connections to a Jupyter notebook
     * If using Google token-based authorization to a Jupyter notebook, the Leo proxy accepts a Google token passed as a cookie value. This endpoint facilitates setting that cookie. It accepts a bearer token in an Authorization header and responds with a Set-Cookie header. 
     * @param googleProject  (required)
     * @param clusterName clusterName (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> setCookieWithHttpInfo(String googleProject, String clusterName) throws ApiException {
        com.squareup.okhttp.Call call = setCookieValidateBeforeCall(googleProject, clusterName, null, null);
        return apiClient.execute(call);
    }

    /**
     * (Deprecated) Sets a browser cookie needed to authorize connections to a Jupyter notebook (asynchronously)
     * If using Google token-based authorization to a Jupyter notebook, the Leo proxy accepts a Google token passed as a cookie value. This endpoint facilitates setting that cookie. It accepts a bearer token in an Authorization header and responds with a Set-Cookie header. 
     * @param googleProject  (required)
     * @param clusterName clusterName (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call setCookieAsync(String googleProject, String clusterName, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = setCookieValidateBeforeCall(googleProject, clusterName, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /**
     * Build call for welderCreateStorageLink
     * @param googleProject googleProject (required)
     * @param clusterName clusterName (required)
     * @param body  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call welderCreateStorageLinkCall(String googleProject, String clusterName, StorageLink body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/proxy/{googleProject}/{clusterName}/welder/storageLinks"
            .replaceAll("\\{" + "googleProject" + "\\}", apiClient.escapeString(googleProject.toString()))
            .replaceAll("\\{" + "clusterName" + "\\}", apiClient.escapeString(clusterName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "googleoauth" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call welderCreateStorageLinkValidateBeforeCall(String googleProject, String clusterName, StorageLink body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'googleProject' is set
        if (googleProject == null) {
            throw new ApiException("Missing the required parameter 'googleProject' when calling welderCreateStorageLink(Async)");
        }
        
        // verify the required parameter 'clusterName' is set
        if (clusterName == null) {
            throw new ApiException("Missing the required parameter 'clusterName' when calling welderCreateStorageLink(Async)");
        }
        
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling welderCreateStorageLink(Async)");
        }
        

        com.squareup.okhttp.Call call = welderCreateStorageLinkCall(googleProject, clusterName, body, progressListener, progressRequestListener);
        return call;





    }

    /**
     * creates the specified storage link configuration for the cluster
     * 
     * @param googleProject googleProject (required)
     * @param clusterName clusterName (required)
     * @param body  (required)
     * @return StorageLink
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public StorageLink welderCreateStorageLink(String googleProject, String clusterName, StorageLink body) throws ApiException {
                // Generate an OpenCensus tracing span for this API method call.
        Scope scope = tracer.spanBuilderWithExplicitParent("NotebooksApi.welderCreateStorageLink", tracer.getCurrentSpan())
            .setSpanKind(Span.Kind.CLIENT).startScopedSpan();
        Span span = tracer.getCurrentSpan();
        // Some of these attribute keys use naming from the OpenCensus standard. See
        // https://github.com/census-instrumentation/opencensus-specs/blob/master/trace/HTTP.md
        span.putAttribute("package", AttributeValue.stringAttributeValue("org.pmiops.workbench.notebooks.api"));
        span.putAttribute("http.host", AttributeValue.stringAttributeValue(apiClient.getBasePath()));
        span.putAttribute("http.path", AttributeValue.stringAttributeValue("/proxy/{googleProject}/{clusterName}/welder/storageLinks"));
        span.putAttribute("http.method", AttributeValue.stringAttributeValue("POST"));
        span.putAttribute("description", AttributeValue.stringAttributeValue("creates the specified storage link configuration for the cluster"));
        span.putAttribute("connectionTimeout", AttributeValue.longAttributeValue(apiClient.getConnectTimeout()));
            span.putAttribute("responseType", AttributeValue.stringAttributeValue("StorageLink"));

        try {
            // Create and execute the API request.
            ApiResponse<StorageLink> resp = welderCreateStorageLinkWithHttpInfo(googleProject, clusterName, body);
            span.putAttribute("http.status_code", AttributeValue.longAttributeValue(resp.getStatusCode()));
            return resp.getData();
        } catch (ApiException e) {
            // We could be more intelligent about aligning HTTP error codes with OpenCensus canonical
            // status codes... but this is for tracing purposes, not logging / deeper debugging, so we'll
            // be lazy and use UNKNOWN, including the actual code as an attribute.
            span.setStatus(Status.UNKNOWN.withDescription(e.getMessage()));
            span.putAttribute("http.status_code", AttributeValue.longAttributeValue(e.getCode()));
            span.putAttribute("errorMessage", AttributeValue.stringAttributeValue(e.getMessage()));
            throw e;
        } finally {
            scope.close();
        }

    }

    /**
     * creates the specified storage link configuration for the cluster
     * 
     * @param googleProject googleProject (required)
     * @param clusterName clusterName (required)
     * @param body  (required)
     * @return ApiResponse&lt;StorageLink&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<StorageLink> welderCreateStorageLinkWithHttpInfo(String googleProject, String clusterName, StorageLink body) throws ApiException {
        com.squareup.okhttp.Call call = welderCreateStorageLinkValidateBeforeCall(googleProject, clusterName, body, null, null);
        Type localVarReturnType = new TypeToken<StorageLink>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * creates the specified storage link configuration for the cluster (asynchronously)
     * 
     * @param googleProject googleProject (required)
     * @param clusterName clusterName (required)
     * @param body  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call welderCreateStorageLinkAsync(String googleProject, String clusterName, StorageLink body, final ApiCallback<StorageLink> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = welderCreateStorageLinkValidateBeforeCall(googleProject, clusterName, body, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<StorageLink>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for welderLocalize
     * @param googleProject googleProject (required)
     * @param clusterName clusterName (required)
     * @param body  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call welderLocalizeCall(String googleProject, String clusterName, Localize body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/proxy/{googleProject}/{clusterName}/welder/objects"
            .replaceAll("\\{" + "googleProject" + "\\}", apiClient.escapeString(googleProject.toString()))
            .replaceAll("\\{" + "clusterName" + "\\}", apiClient.escapeString(clusterName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "googleoauth" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call welderLocalizeValidateBeforeCall(String googleProject, String clusterName, Localize body, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'googleProject' is set
        if (googleProject == null) {
            throw new ApiException("Missing the required parameter 'googleProject' when calling welderLocalize(Async)");
        }
        
        // verify the required parameter 'clusterName' is set
        if (clusterName == null) {
            throw new ApiException("Missing the required parameter 'clusterName' when calling welderLocalize(Async)");
        }
        
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling welderLocalize(Async)");
        }
        

        com.squareup.okhttp.Call call = welderLocalizeCall(googleProject, clusterName, body, progressListener, progressRequestListener);
        return call;





    }

    /**
     * 
     * 
     * @param googleProject googleProject (required)
     * @param clusterName clusterName (required)
     * @param body  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public void welderLocalize(String googleProject, String clusterName, Localize body) throws ApiException {
                // Generate an OpenCensus tracing span for this API method call.
        Scope scope = tracer.spanBuilderWithExplicitParent("NotebooksApi.welderLocalize", tracer.getCurrentSpan())
            .setSpanKind(Span.Kind.CLIENT).startScopedSpan();
        Span span = tracer.getCurrentSpan();
        // Some of these attribute keys use naming from the OpenCensus standard. See
        // https://github.com/census-instrumentation/opencensus-specs/blob/master/trace/HTTP.md
        span.putAttribute("package", AttributeValue.stringAttributeValue("org.pmiops.workbench.notebooks.api"));
        span.putAttribute("http.host", AttributeValue.stringAttributeValue(apiClient.getBasePath()));
        span.putAttribute("http.path", AttributeValue.stringAttributeValue("/proxy/{googleProject}/{clusterName}/welder/objects"));
        span.putAttribute("http.method", AttributeValue.stringAttributeValue("POST"));
        span.putAttribute("description", AttributeValue.stringAttributeValue(""));
        span.putAttribute("connectionTimeout", AttributeValue.longAttributeValue(apiClient.getConnectTimeout()));

        try {
            // Create and execute the API request.
            welderLocalizeWithHttpInfo(googleProject, clusterName, body);
        } catch (ApiException e) {
            // We could be more intelligent about aligning HTTP error codes with OpenCensus canonical
            // status codes... but this is for tracing purposes, not logging / deeper debugging, so we'll
            // be lazy and use UNKNOWN, including the actual code as an attribute.
            span.setStatus(Status.UNKNOWN.withDescription(e.getMessage()));
            span.putAttribute("http.status_code", AttributeValue.longAttributeValue(e.getCode()));
            span.putAttribute("errorMessage", AttributeValue.stringAttributeValue(e.getMessage()));
            throw e;
        } finally {
            scope.close();
        }

    }

    /**
     * 
     * 
     * @param googleProject googleProject (required)
     * @param clusterName clusterName (required)
     * @param body  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> welderLocalizeWithHttpInfo(String googleProject, String clusterName, Localize body) throws ApiException {
        com.squareup.okhttp.Call call = welderLocalizeValidateBeforeCall(googleProject, clusterName, body, null, null);
        return apiClient.execute(call);
    }

    /**
     *  (asynchronously)
     * 
     * @param googleProject googleProject (required)
     * @param clusterName clusterName (required)
     * @param body  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call welderLocalizeAsync(String googleProject, String clusterName, Localize body, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = welderLocalizeValidateBeforeCall(googleProject, clusterName, body, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
}
