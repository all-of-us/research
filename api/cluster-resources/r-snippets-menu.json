{
  "name": "All of Us R snippets",
  "sub-menu": [
    {
      "name": "Setup",
      "snippet": "# Only install missing libraries, per https://stackoverflow.com/a/23286257/4138705.\ninstall_if_missing <- function(packages) {\n  if (length(setdiff(packages, rownames(installed.packages()))) > 0) {\n    install.packages(setdiff(packages, rownames(installed.packages())))\n  }\n}\ninstall_if_missing(c('viridis', 'ggthemes', 'scales', 'skimr', 'lubridate', 'bigrquery', 'tidyverse'))\n\nlibrary(viridis)    # A nice color scheme for plots.\nlibrary(ggthemes)   # Common themes to change the look and feel of plots.\nlibrary(scales)     # Graphical scales map data to aesthetics in plots.\nlibrary(skimr)      # Better summaries of data.\nlibrary(lubridate)  # Date library from the tidyverse.\nlibrary(bigrquery)  # BigQuery R client.\nlibrary(tidyverse)  # Data wrangling packages.\n\n## CHANGE THESE AS NEEDED - default parameter values for snippets.\nDATASET <- 'aou-res-curation-output-prod.R2019Q1R2'\nMEASUREMENT_OF_INTEREST <- 'hemoglobin'\n# Tip: the next four parameters could be set programmatically using one row from\n# the result of measurements_of_interest_summary.sql\nMEASUREMENT_CONCEPT_ID <- 3000963        # Hemoglobin\nUNIT_CONCEPT_ID <- 8713                  # gram per deciliter\nMEASUREMENT_NAME <- '<this should be the measurement name>'\nUNIT_NAME <- '<this should be the unit name>'\n\n## BigQuery setup.\nBILLING_PROJECT_ID <- Sys.getenv('GOOGLE_PROJECT')\nbigrquery::set_service_token(Ronaldo::getServiceAccountKey())\n\n## Plot setup.\ntheme_set(theme_minimal()) # Default theme for plots.\n\n#' Returns a data frame with a y position and a label, for use annotating ggplot boxplots.\n#'\n#' @param d A data frame.\n#' @return A data frame with column y as max and column label as length.\nget_boxplot_fun_data <- function(df) {\n  return(data.frame(y = max(df), label = stringr::str_c('N = ', length(df))))\n}\n"
    },
    {
      "name": "measurement_of_interest.sql",
      "snippet": "\nmeasurement_of_interest_df <- bq_table_download(bq_project_query(\n    BILLING_PROJECT_ID,\n    query = str_glue('\n-- Return row level data for a measurement.\n--\n-- PARAMETERS:\n--   MEASUREMENT_CONCEPT_ID: for example 3000963  # Hemoglobin\n--   UNIT_CONCEPT_ID: for example 8713            # gram per deciliter\n\nWITH\n  --\n  -- Retrieve participants birthdate and gender.\n  --\npersons AS (\n  SELECT\n    person_id,\n    birth_datetime,\n    concept_name AS gender\n  FROM\n    `{DATASET}.person`\n  LEFT JOIN `{DATASET}.concept` ON concept_id = gender_concept_id),\n  --\n  -- Retrieve the row-level data for our measurement of interest.\n  --\nmeasurements AS (\n  SELECT\n    person_id,\n    measurement_id,\n    measurement_concept_id,\n    measurement_date,\n    measurement_datetime,\n    measurement_type_concept_id,\n    operator_concept_id,\n    value_as_number,\n    value_as_concept_id,\n    unit_concept_id,\n    range_low,\n    range_high\n  FROM\n    `{DATASET}.measurement`\n  WHERE\n    measurement_concept_id = {MEASUREMENT_CONCEPT_ID} AND unit_concept_id = {UNIT_CONCEPT_ID}),\n  --\n  -- Get the human-readable names for the site from which the measurement came.\n  --\nsites AS (\n  SELECT\n    measurement_id,\n    src_hpo_id\n  FROM\n    `{DATASET}._mapping_measurement`\n  GROUP BY  # This GROUP BY is here to deal with duplicate rows in the R2019Q1R2 release of the table.\n    1, 2)\n  --\n  -- Lastly, JOIN all this data together so that we have the birthdate, gender and site for each measurement.\n  --\nSELECT\n  persons.*,\n  sites.src_hpo_id,\n  measurements.* EXCEPT(person_id, measurement_id)\nFROM\n  measurements\nLEFT JOIN\n  persons USING (person_id)\nLEFT JOIN\n  sites USING (measurement_id)\nORDER BY\n  person_id,\n  measurement_id\n\n')))\n\nprint(skim(measurement_of_interest_df))\n\nhead(measurement_of_interest_df)"
    },
    {
      "name": "measurement_of_interest_by_age_and_gender.ggplot",
      "snippet": "# This plot assumes that most_recent_measurement_of_interest.sql has been run.\noptions(repr.plot.height = 14, repr.plot.width = 8)\n\nmeasurement_of_interest_df %>%\n    filter(value_as_number < 9999999) %>% # Get rid of nonsensical outliers.\n    # TODO: the logic to compute and bin age could be translated to SQL for easy reuse from Python.\n    mutate(age = year(as.period(interval(start = birth_datetime, end = now())))) %>%\n    ggplot(aes(x = cut_width(age, width = 5, boundary = 0), y = value_as_number)) +\n    geom_boxplot() +\n    stat_summary(fun.data = get_boxplot_fun_data, geom = 'text', size = 2,\n                 position = position_dodge(width = 0.9), vjust = -0.8) +\n#    scale_y_log10() +  # Uncomment if the data looks skewed.\n    coord_flip() +\n    facet_wrap(~ gender, nrow = length(unique(measurement_of_interest_df$gender))) +\n    xlab('age') +\n    ylab(str_glue('{UNIT_NAME}')) +\n    ggtitle(str_glue('All {MEASUREMENT_NAME} measurements, by age, faceted by gender'))\n"
    },
    {
      "name": "measurement_of_interest_by_gender.ggplot",
      "snippet": "# This plot assumes that measurement_of_interest.sql has been run.\noptions(repr.plot.height = 4, repr.plot.width = 8)\n\nmeasurement_of_interest_df %>%\n    filter(value_as_number < 9999999) %>% # Get rid of nonsensical outliers.\n    ggplot(aes(x = gender, y = value_as_number)) +\n    geom_boxplot() +\n    stat_summary(fun.data = get_boxplot_fun_data, geom = 'text', size = 2,\n                 position = position_dodge(width = 0.9), vjust = -0.8) +\n#    scale_y_log10() +  # Uncomment if the data looks skewed.\n    ylab(str_glue('{UNIT_NAME}')) +\n    ggtitle(str_glue('All {MEASUREMENT_NAME} measurements, by gender'))\n"
    },
    {
      "name": "measurement_of_interest_by_site.ggplot",
      "snippet": "# This plot assumes that measurement_of_interest.sql has been run.\noptions(repr.plot.height = 4, repr.plot.width = 8)\n\nmeasurement_of_interest_df %>%\n    filter(value_as_number < 9999999) %>% # Get rid of nonsensical outliers.\n    ggplot(aes(x = src_hpo_id, y = value_as_number)) +\n    geom_boxplot() +\n    stat_summary(fun.data = get_boxplot_fun_data, geom = 'text', size = 2,\n                 position = position_dodge(width = 0.9), vjust = -0.8) +\n#    scale_y_log10() +  # Uncomment if the data looks skewed.\n    coord_flip() +\n    ylab(str_glue('{UNIT_NAME}')) +\n    ggtitle(str_glue('All {MEASUREMENT_NAME} measurements, by site'))\n"
    },
    {
      "name": "measurements_of_interest_summary.sql",
      "snippet": "\nmeasurements_of_interest_summary_df <- bq_table_download(bq_project_query(\n    BILLING_PROJECT_ID,\n    query = str_glue('\n-- Compute summary information for our measurements of interest.\n--\n-- PARAMETERS:\n--   MEASUREMENT_OF_INTEREST: a case-insensitive string, such as \"hemoglobin\", to be compared\n--                            to all measurement concept names to identify those of interest\n\nWITH\n  --\n  -- Use a case insensitive string to search the measurement concept names of those\n  -- measurements we do have in the measurements table.\n  --\n  labs_of_interest AS (\n  SELECT\n    measurement_concept_id,\n    measurement_concept.concept_name AS measurement_name,\n    unit_concept_id,\n    unit_concept.concept_name AS unit_name\n  FROM\n    `{DATASET}.measurement`\n  LEFT JOIN `{DATASET}.concept` AS measurement_concept\n  ON measurement_concept.concept_id = measurement_concept_id\n  LEFT JOIN `{DATASET}.concept` AS unit_concept\n  ON unit_concept.concept_id = unit_concept_id\n  WHERE\n    REGEXP_CONTAINS(measurement_concept.concept_name, r\"(?i){MEASUREMENT_OF_INTEREST}\")\n  GROUP BY\n    measurement_concept_id,\n    unit_concept_id,\n    measurement_concept.concept_name,\n    unit_concept.concept_name\n)\n  --\n  -- Summarize the information about each measurement concept of interest that our\n  -- prior query identified.\n  --\nSELECT\n  measurement_name AS measurement,\n  IFNULL(unit_name, \"NA\") AS unit,\n  COUNT(1) AS N,\n  COUNTIF(value_as_number IS NULL\n    AND (value_as_concept_id IS NULL\n      OR value_as_concept_id = 0)) AS missing,\n  MIN(value_as_number) AS min,\n  MAX(value_as_number) AS max,\n  AVG(value_as_number) AS avg,\n  STDDEV(value_as_number) AS stddev,\n  APPROX_QUANTILES(value_as_number, 4) AS quantiles,\n  COUNTIF(value_as_number IS NOT NULL) AS num_numeric_values,\n  COUNTIF(value_as_concept_id IS NOT NULL\n      AND value_as_concept_id != 0) AS num_concept_values,\n  COUNTIF(operator_concept_id IS NOT NULL) AS num_operators,\n  measurement_concept_id,\n  unit_concept_id\nFROM\n  `{DATASET}.measurement`\nINNER JOIN\n  labs_of_interest\nUSING\n  (measurement_concept_id, unit_concept_id)\nGROUP BY\n  measurement_concept_id,\n  measurement_name,\n  unit_concept_id,\n  unit_name\nORDER BY\n  N DESC\n\n')))\n\nprint(skim(measurements_of_interest_summary_df))\n\nhead(measurements_of_interest_summary_df)"
    },
    {
      "name": "most_recent_measurement_of_interest.sql",
      "snippet": "\nmost_recent_measurement_of_interest_df <- bq_table_download(bq_project_query(\n    BILLING_PROJECT_ID,\n    query = str_glue('\n-- Return row level data for a measurement, limited to only the most recent result per person.\n--\n-- PARAMETERS:\n--   MEASUREMENT_CONCEPT_ID: for example 3000963  # Hemoglobin\n--   UNIT_CONCEPT_ID: for example 8713            # gram per deciliter\n\nWITH\n  --\n  -- Retrieve participants birthdate and gender.\n  --\npersons AS (\n  SELECT\n    person_id,\n    birth_datetime,\n    concept_name AS gender\n  FROM\n    `{DATASET}.person`\n  LEFT JOIN `{DATASET}.concept` ON concept_id = gender_concept_id),\n  --\n  -- Retrieve the row-level data for our measurement of interest. Also compute\n  -- a new column for the recency rank of the measurement per person, a rank of\n  -- of 1 being the most recent lab result for that person.\n  --\nmeasurements AS (\n  SELECT\n    person_id,\n    measurement_id,\n    measurement_concept_id,\n    unit_concept_id,\n    measurement_date,\n    measurement_datetime,\n    measurement_type_concept_id,\n    operator_concept_id,\n    value_as_number,\n    value_as_concept_id,\n    range_low,\n    range_high,\n    ROW_NUMBER() OVER (PARTITION BY person_id\n                       ORDER BY measurement_date DESC,\n                                measurement_datetime DESC,\n                                measurement_id DESC) AS recency_rank\n\n  FROM\n    `{DATASET}.measurement`\n  WHERE\n    measurement_concept_id = {MEASUREMENT_CONCEPT_ID} AND unit_concept_id = {UNIT_CONCEPT_ID}),\n  --\n  -- Get the human-readable names for the site from which the measurement came.\n  --\nsites AS (\n  SELECT\n    measurement_id,\n    src_hpo_id\n  FROM\n    `{DATASET}._mapping_measurement`\n  GROUP BY  # This GROUP BY is here to deal with duplicate rows in the R2019Q1R2 release of the table.\n    1, 2)\n  --\n  -- Lastly, JOIN all this data together so that we have the birthdate, gender and site for each\n  -- measurement, retaining only the most recent result per person.\n  --\nSELECT\n  persons.*,\n  sites.src_hpo_id,\n  measurements.* EXCEPT(person_id, measurement_id, recency_rank)\nFROM\n  measurements\nLEFT JOIN\n  persons USING (person_id)\nLEFT JOIN\n  sites USING (measurement_id)\nWHERE\n  recency_rank = 1\nORDER BY\n  person_id,\n  measurement_id\n\n')))\n\nprint(skim(most_recent_measurement_of_interest_df))\n\nhead(most_recent_measurement_of_interest_df)"
    },
    {
      "name": "most_recent_measurement_of_interest_by_age_and_gender.ggplot",
      "snippet": "# This plot assumes that most_recent_measurement_of_interest.sql has been run.\noptions(repr.plot.height = 14, repr.plot.width = 8)\n\nmost_recent_measurement_of_interest_df %>%\n    filter(value_as_number < 9999999) %>% # Get rid of nonsensical outliers.\n    # TODO: the logic to compute and bin age could be translated to SQL for easy reuse from Python.\n    mutate(age = year(as.period(interval(start = birth_datetime, end = now())))) %>%\n    ggplot(aes(x = cut_width(age, width = 5, boundary = 0), y = value_as_number)) +\n    geom_boxplot() +\n    stat_summary(fun.data = get_boxplot_fun_data, geom = 'text', size = 2,\n                 position = position_dodge(width = 0.9), vjust = -0.8) +\n#    scale_y_log10() +  # Uncomment if the data looks skewed.\n    coord_flip() +\n    facet_wrap(~ gender, nrow = length(unique(most_recent_measurement_of_interest_df$gender))) +\n    xlab('age') +\n    ylab(str_glue('{UNIT_NAME}')) +\n    ggtitle(str_glue('Most recent {MEASUREMENT_NAME} measurement\\nper person, by age, faceted by gender'))\n"
    },
    {
      "name": "most_recent_measurement_of_interest_by_gender.ggplot",
      "snippet": "# This plot assumes that most_recent_measurement_of_interest.sql has been run.\noptions(repr.plot.height = 4, repr.plot.width = 8)\n\nmost_recent_measurement_of_interest_df %>%\n    filter(value_as_number < 9999999) %>% # Get rid of nonsensical outliers.\n    ggplot(aes(x = gender, y = value_as_number)) +\n    geom_boxplot() +\n    stat_summary(fun.data = get_boxplot_fun_data, geom = 'text', size = 2,\n                 position = position_dodge(width = 0.9), vjust = -0.8) +\n#    scale_y_log10() +  # Uncomment if the data looks skewed.\n    ylab(str_glue('{UNIT_NAME}')) +\n    ggtitle(str_glue('Most recent {MEASUREMENT_NAME} measurement\\nper person, by gender'))\n"
    },
    {
      "name": "most_recent_measurement_of_interest_by_site.ggplot",
      "snippet": "# This plot assumes that most_recent_measurement_of_interest.sql has been run.\noptions(repr.plot.height = 4, repr.plot.width = 8)\n\nmost_recent_measurement_of_interest_df %>%\n    filter(value_as_number < 9999999) %>% # Get rid of nonsensical outliers.\n    ggplot(aes(x = src_hpo_id, y = value_as_number)) +\n    geom_boxplot() +\n    stat_summary(fun.data = get_boxplot_fun_data, geom = 'text', size = 2,\n                 position = position_dodge(width = 0.9), vjust = -0.8) +\n#    scale_y_log10() +  # Uncomment if the data looks skewed.\n    coord_flip() +\n    ylab(str_glue('{UNIT_NAME}')) +\n    ggtitle(str_glue('Most recent {MEASUREMENT_NAME} measurement\\nper person, by site'))\n"
    },
    {
      "name": "number_of_participants_with_measurements.sql",
      "snippet": "\nnumber_of_participants_with_measurements_df <- bq_table_download(bq_project_query(\n    BILLING_PROJECT_ID,\n    query = str_glue('\n-- Compute the count of all unique participants in All of Us\n-- that have at least one measurement.\nSELECT\n  COUNT(DISTINCT person_id) AS number_of_participants_with_measurements\nFROM\n  `{DATASET}.measurement`\n')))\n\nprint(skim(number_of_participants_with_measurements_df))\n\nhead(number_of_participants_with_measurements_df)"
    },
    {
      "name": "number_of_participants_with_med_conditions.sql",
      "snippet": "\nnumber_of_participants_with_med_conditions_df <- bq_table_download(bq_project_query(\n    BILLING_PROJECT_ID,\n    query = str_glue('\n-- Compute the count of all unique participants in All of Us\n-- that have at least one condition.\nSELECT\n  COUNT(DISTINCT person_id) AS number_of_participants_with_med_conditions\nFROM\n  `{DATASET}.condition_occurrence`\n')))\n\nprint(skim(number_of_participants_with_med_conditions_df))\n\nhead(number_of_participants_with_med_conditions_df)"
    },
    {
      "name": "total_number_of_participants.sql",
      "snippet": "\ntotal_number_of_participants_df <- bq_table_download(bq_project_query(\n    BILLING_PROJECT_ID,\n    query = str_glue('\n-- Compute the count of all unique participants in AoU.\nSELECT\n  COUNT(DISTINCT person_id) AS total_number_of_participants\nFROM\n  `{DATASET}.person`\n\n')))\n\nprint(skim(total_number_of_participants_df))\n\nhead(total_number_of_participants_df)"
    }
  ]
}
