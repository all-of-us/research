#!/usr/bin/env python3

import argparse
import subprocess
import sys
import time

# Given the 'expected' cohort vcf and the actual cohort VCF, we want to check four things:
# 1) The VCFs have the same number of variants
# 2) The VCFs have the same number of samples
# 3) The VCFs have the same allele frequency across sites (with fuzziness for float variance)
# 4) All genotypes match for, say, the first sample in the cohort
def main():
  start = time.time()
  parser = argparse.ArgumentParser(description="Validate a VCF generated by cohort extraction")
  parser.add_argument('--expected', required=True, help="A bgzipped VCF. An index file of the same basename must exist in the same directory.")
  parser.add_argument('--actual', required=True, help="A bgzipped VCF. An index file of the same basename must exist in the same directory.")
  parser.add_argument('--sample', help="The name of one sample for which to validate all genotypes in both VCFs")
  args = parser.parse_args()

  # bcftools stats counts a bunch of stuff in each vcf - records, types of variants,
  # types of substitution, distribution of variants, etc. We don't care about most
  # of them but also can't filter down. This handles 1) and 2).
  expected_stats_proc = subprocess.run(["bcftools", "stats", args.expected], capture_output=True, text=True)
  actual_stats_proc = subprocess.run(["bcftools", "stats", args.actual], capture_output=True, text=True)
  expected_stats = expected_stats_proc.stdout.split("\n")
  actual_stats = actual_stats_proc.stdout.split("\n")

  # SN stands for Summary Numbers, which covers things like number of samples,
  # number of records, number of indels, SNPs, multiallelic sites, etc. May as
  # well check all of them.
  expected_summary = [stat for stat in expected_stats if stat.startswith('SN')]
  actual_summary = [stat for stat in actual_stats if stat.startswith('SN')]
  # We'll grab number of samples for later convenience
  samples = 0
  for i in range(0, len(expected_summary)):
    expected_stat = expected_summary[i].split("\t")
    actual_stat = actual_summary[i].split("\t")
    if (expected_stat[-1] != actual_stat[-1]):
      print(f"Discrepancy in summary stat '{expected_stat[-2]}': Expected {expected_stat[-1]}, Actual {actual_stat[-2]}")
      sys.exit()
    if (actual_stat[2] == "number of samples:"):
      samples = expected_stat[3]

  # grab the first sample and pull that sample out of both vcfs.
  sample_to_check_gts = args.sample if args.sample else None
  if (sample_to_check_gts is None):
    expected_sample_names_proc = subprocess.run(["bcftools", "query", "-l", args.expected], capture_output=True, text=True)
    expected_sample_names = expected_sample_names_proc.stdout.replace("\'", "").split("\n")
    sample_to_check_gts = expected_sample_names[0]

  # bcftools query extracts particular fields from each field, such as allele frequency or genotype.
  expected_query_proc = subprocess.run(["bcftools", "query", "-f", "'%CHROM %POS %AF [%GT]\n'", "-s", sample_to_check_gts, args.expected], capture_output=True, text=True)
  actual_query_proc = subprocess.run(["bcftools", "query", "-f", "'%CHROM %POS %AF [%GT]\n'", "-s", sample_to_check_gts, args.actual], capture_output=True, text=True)
  # apPARently there is a newline on the end thus the splice
  expected_query_stringy = expected_query_proc.stdout.replace("\'", "").split("\n")[:-1]
  actual_query_stringy = actual_query_proc.stdout.replace("\'", "").split("\n")[:-1]
  expected_af = [af.split() for af in expected_query_stringy]
  actual_af = [af.split() for af in actual_query_stringy]

  # munge - map by chromosome then by position.
  expected_by_chrom_pos = {}
  for chrom, pos, af, gt in expected_af:
    # af is pretty straightforward.
    if chrom in expected_by_chrom_pos:
      if pos in expected_by_chrom_pos:
        expected_by_chrom_pos[chrom][pos]['af'] = af
        expected_by_chrom_pos[chrom][pos]['gt'] = gt
      else:
        expected_by_chrom_pos[chrom][pos] = {}
        expected_by_chrom_pos[chrom][pos]['af'] = af
        expected_by_chrom_pos[chrom][pos]['gt'] = gt
    else:
      expected_by_chrom_pos[chrom] = {}
      expected_by_chrom_pos[chrom][pos] = {}
      expected_by_chrom_pos[chrom][pos]['af'] = af
      expected_by_chrom_pos[chrom][pos]['gt'] = gt

  # and the same for actual.
  actual_by_chrom_pos = {}
  for chrom, pos, af, gt in actual_af:
    # actual af
    if chrom in actual_by_chrom_pos:
      if pos in actual_by_chrom_pos:
        actual_by_chrom_pos[chrom][pos]['af'] = af
        actual_by_chrom_pos[chrom][pos]['gt'] = gt
      else:
        actual_by_chrom_pos[chrom][pos] = {}
        actual_by_chrom_pos[chrom][pos]['af'] = af
        actual_by_chrom_pos[chrom][pos]['gt'] = gt
    else:
      actual_by_chrom_pos[chrom] = {}
      actual_by_chrom_pos[chrom][pos] = {}
      actual_by_chrom_pos[chrom][pos]['af'] = af
      actual_by_chrom_pos[chrom][pos]['gt'] = gt

  # chromosomes SHOULD be the same for both of these. we're probably doing them all on humans.
  for chrom in expected_by_chrom_pos.keys():
    expected_positions = sorted(expected_by_chrom_pos[chrom].keys())
    actual_positions = sorted(actual_by_chrom_pos[chrom].keys())
    if expected_positions != actual_positions:
      print(f"Discrepancy on chromosome {chrom}: sequenced positions are not the same")
      sys.exit()
    else:
      for pos in expected_positions:
        # validate AF. This handles 3)
        if expected_by_chrom_pos[chrom][pos]['af'] != actual_by_chrom_pos[chrom][pos]['af']:
          print(f"Discrepancy in allele frequency on chromosome {chrom} at position {pos}: Expected {expected_by_chrom_pos[chrom][pos]['af']}, Actual {actual_af_by_chrom_pos[chrom][pos]['af']}")
          sys.exit()
        # validate gt. This handles 4)
        if expected_by_chrom_pos[chrom][pos]['gt'] != actual_by_chrom_pos[chrom][pos]['gt']:
          print(f"Discrepancy in genotype on chromosome {chrom} at position {pos}: Expected {expected_by_chrom_pos[chrom][pos]['gt']}, Actual {actual_by_chrom_pos[chrom][pos]['gt']}")
          sys.exit()

  print("All good, this looks like the same set of people.")
  end = time.time()
  print(f"Elapsed time: {end-start} seconds for {samples} samples")


###############################################################################
if __name__ == "__main__":
  main()